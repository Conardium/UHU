/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "GestorJuegos.h"

//#include <cstring>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define COD argp->pCod
#define FIL argp->pFil
#define COL argp->pCol
#define VAL argp->pVal


//----- Estructura de datos para almacenacenar en memoria dinamica los sudokus-----

typedef struct{
	int Codigo;
	char Tablero[9][9];
	TDificultad Dificultad;
} TJuego;

TJuego *Sudokus = NULL; //Vector dinamico que almacena los diferentes Sudokus
int NSudokus = 0; //Numero total de Sudokus creados

int CodSudoku = 1; //Codigo que se le asignará al sudoku al crearse (global)
//---------------------------------------------------------------------------------


// ############## Definición de las funciones del servidor ###############
int BuscarPorFila(int pos, int pFil, char pVal){

    int Cuantos = 0;
    for (int c = 0; c < 9 && Cuantos < 2; c++){
    	if (Sudokus[pos].Tablero[pFil][c] == pVal){
    		Cuantos++;
    	}
    }
        
    return Cuantos;
}


int BuscarPorColumna(int pos, int pCol, char pVal){

    int Cuantos = 0; 
    for (int f = 0; f < 9 && Cuantos < 2; f++)
        if (Sudokus[pos].Tablero[f][pCol] == pVal)
            Cuantos++;
    return Cuantos;
}


int BuscarPorBloque(int pos, int pFil, int pCol, char pVal){
    
    int minF = (pFil / 3) * 3;
    int minC = (pCol / 3) * 3;
    int maxF = minF + 3;
    int maxC = minC + 3;

    int Cuantos = 0; //Cuantas ocurrencias de pVal hay en el bloque correspondiente
    for (int f = minF; f < maxF && Cuantos < 2; f++)
        for (int c = minC; c < maxC && Cuantos < 2; c++)
            if (Sudokus[pos].Tablero[f][c] == pVal)
                Cuantos++;
    return Cuantos;
}


void Inicializar(int pos, TDificultad pDifi){ //Establece la dificultad y pone todas las casillas vacias
    Sudokus[pos].Dificultad = pDifi;
    for (int f = 0; f < 9; f++) {
        for (int c = 0; c < 9; c++) {
            Sudokus[pos].Tablero[f][c] = ' ';
        }
    }
}


int Num_Huecos(int pos)
{
	static int total;

	if(pos == -1){
	    total = 81;
	}
	else{
	    total = 0;
	    for (int f = 0; f < 9; f++)
                for (int c = 0; c < 9; c++)
                    if (Sudokus[pos].Tablero[f][c] == ' ')
                    	total++;
	}	
	return total;
}


char Obtener_Valor(int pos, TFC tfc)
{
	static char valor;

	if(pos == -1){
	    valor = ' ';
	}
	else{
	    valor = Sudokus[pos].Tablero[tfc.pFil][tfc.pCol];
	}

	return valor;
}


bool_t Poner_Valor(int pos, TFCV tfcv)
{
	static bool_t ok;
	
	//Comprobamos que el valor no sea negativo o cero
	if(tfcv.pVal <= 0)
	    ok = FALSE;
	    
	else{
	    Sudokus[pos].Tablero[tfcv.pFil][tfcv.pCol] = tfcv.pVal;
	    ok = TRUE;
	}
	
	return ok;
}


bool_t Comprobar_Valor(int pos, TFCV tfcv)
{
	static bool_t ok;

        ok = TRUE;
        
	if(BuscarPorFila(pos, tfcv.pFil, tfcv.pVal) != 1 || BuscarPorColumna(pos, tfcv.pCol, tfcv.pVal) != 1 || BuscarPorBloque(pos, tfcv.pFil, tfcv.pCol, tfcv.pVal) != 1){
	    ok = FALSE;
	}

	return ok;
}
// #######################################################################


//$$$ Funcion para obtener la posición dentro de Sudokus segun el codigo pasado $$$$
int BuscarSudoku(int cod){

    int pos = -1;
    
    if(cod != 0){
        for(int i = 0; i < NSudokus; i++){
    	    if(Sudokus[i].Codigo == cod){
    	    	pos = i;
    	    }
        }
    }
    //printf("Posicion vale: %d", pos);
//    fflush(stdout);
    return pos;
}
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$


// =============== Servicios del Servidor, que llamará el cliente ==============
int *
nuevo_1_svc(TDificultad *argp, struct svc_req *rqstp) //Crea un Nuevo Sudoku y devuelve el código de este
{
	static int  result;

	//Inicialmente: CodSudoku = 1 y NSudokus = 0

	int f, c;
	char Valor;
	TFCV aux;
	
	Sudokus = (TJuego *)realloc(Sudokus, sizeof(TJuego)*(NSudokus+1));
	Sudokus[NSudokus].Codigo = CodSudoku;
	
	CodSudoku++;
	NSudokus++; // +1 Sudoku creado
	
	result = CodSudoku-1;
	
	aux.pCod = CodSudoku-1;

	Inicializar(NSudokus-1, *argp);
	
	char ValoresActuales[81];
	srand(time(0));

	for (int i = 0; i < 81; i++)
            ValoresActuales[i] = ' ';
	
	int Pos;
	for (char v = '1'; v <= '9'; v++)
	{
	    Pos = rand()%9;
            while (ValoresActuales[Pos] != ' ')
            {
            	Pos++;
            	if (Pos == 9)
            	    Pos = 0;
            }
            ValoresActuales[Pos] = v;
            
            //Asignamos valores al TFCV aux
            aux.pFil = 0;
            aux.pCol = Pos;
            aux.pVal = v;
            
            Poner_Valor(NSudokus-1 , aux);
	}
	
	
	Pos = 9;
	while (Pos < 81)
	{
	    f = Pos / 9;
            c = Pos % 9;
            Valor = ValoresActuales[Pos] != ' ' ? ValoresActuales[Pos] : '0';
            
            bool_t EsCorrecto = FALSE;
            while (EsCorrecto == FALSE && Valor < '9')
            {
            	Valor++;
            	
            	//Asignamos valores al TFCV aux
            	aux.pFil = f;
            	aux.pCol = c;
            	aux.pVal = Valor;
            	
            	Poner_Valor(NSudokus-1, aux);
            	EsCorrecto = Comprobar_Valor(NSudokus-1, aux);	
            }
            
            if (EsCorrecto == TRUE)
            {
            	ValoresActuales[Pos] = Valor;
            	Pos++;
            }
            else
            {
            	ValoresActuales[Pos] = ' ';
            	aux.pFil = f;
            	aux.pCol = c;
            	aux.pVal = ' ';
            	Poner_Valor(NSudokus-1, aux);
            	Pos--;
            }
	}
	
	
	int NHuecos = 0;
	switch (*argp)
	{
	    case MUY_FACIL:
	    	NHuecos = 10;
	    	break;
	    case FACIL:
	    	NHuecos = 30;
	    	break;
	    case DIFICIL:
	    	NHuecos = 60;
	    	break;
	    case MUY_DIFICIL:
	    	NHuecos = 70;
	    	break;
	    default:
	    	NHuecos = 40;
	}
	
	TFC aux_TFC;
	aux_TFC.pCod = CodSudoku-1;
	
	for (int i = 0; i < NHuecos; i++)
	{
	    do
	    {
	    	f = rand()%9;
	    	c = rand()%9;
	    	
	    	aux_TFC.pFil = f;
            	aux_TFC.pCol = c;
	    }while(Obtener_Valor(NSudokus-1, aux_TFC) == ' ');
	    
	    aux.pFil = f;
	    aux.pCol = c;
	    aux.pVal = ' ';
	    Poner_Valor(NSudokus-1, aux);
	}
	
	return &result;
}

bool_t *
borrar_1_svc(int *argp, struct svc_req *rqstp) //Borra un Sudoku existente
{
	static bool_t  result;

	int pos = BuscarSudoku(*argp); //Obtenemos la posicion en la que se encuentra el sudoku que queremos borrar
	
	if(pos == -1)
	    result = FALSE;
	
	else{
	    Sudokus[pos] = Sudokus[NSudokus-1]; //Sobrescribimos el sudoku que queremos borrar por el ultimo sudoku
	    NSudokus--;
	    Sudokus = (TJuego *)realloc(Sudokus, sizeof(TJuego)*NSudokus); //Hacemos realloc pero esta vez con un sudoku menos
	    result = TRUE;
	}

	return &result;
}

bool_t *
ponervalor_1_svc(TFCV *argp, struct svc_req *rqstp)
{
	static bool_t  result;
	
	int pos = BuscarSudoku(COD);
	result = Poner_Valor(pos, *argp);
	
	return &result;
}

char *
obtenervalor_1_svc(TFC *argp, struct svc_req *rqstp)
{
	static char  result;

	int pos = BuscarSudoku(COD);
	result = Obtener_Valor(pos, *argp);

	return &result;
}

bool_t *
comprobarvalor_1_svc(TFCV *argp, struct svc_req *rqstp)
{
	static bool_t  result;

	int pos = BuscarSudoku(COD);
        result = Comprobar_Valor(pos, *argp);

	return &result;
}

int *
numerohuecos_1_svc(int *argp, struct svc_req *rqstp) //FUNCIONA
{
	static int result;

	int pos = BuscarSudoku(*argp);
	result = Num_Huecos(pos);

	return &result;
}

bool_t *
correcto_1_svc(int *argp, struct svc_req *rqstp)
{
	static bool_t  result;

	result = TRUE;
	char Valor = '1';
	int f, c;
	
	int pos = BuscarSudoku(*argp);
	
	while(Valor <= '9' && result == TRUE)
	{
	    c = 0;
	    while (c < 9 && result == TRUE)
	    {
	    	if(BuscarPorColumna(pos, c, Valor) != 1)
	    	{
	    	    result = FALSE;
	    	}
	    	c++;
	    };
	    
	    f=0;
	    while(f < 9 && result == TRUE)
	    {
            	if (BuscarPorFila(pos, f, Valor) != 1)
            	{
                    result = FALSE;
            	}
               f++;
            };
            
            for (f = 0; f < 9 && result == TRUE; f += 3)
            {
            	for (c = 0; c < 9 && result == TRUE; c += 3)
            	{
            	    if (BuscarPorBloque(pos, f, c, Valor) != 1)
                   {
                        result = FALSE;
                   }
            	}
            }
            Valor++;
	}

	return &result;
}

RCadena *
ayuda_1_svc(TFC *argp, struct svc_req *rqstp)
{
	static RCadena  result;

	char Valor;
	int posicion=0;
	
	int pos = BuscarSudoku(COD);
	
	strcpy(result.Contenido, "");
	char v = Obtener_Valor(pos, *argp);
	
	TFCV aux; //Creamos un TFCV aux. para los svc poner y comprobar valor
	aux.pCod = COD;
	aux.pFil = FIL;
	aux.pCol = COL;
	
	if(v == ' ')
	{
	    Valor = '1';
	    
	    while(Valor <= '9')
	    {
	        aux.pVal = Valor;   
	        Poner_Valor(pos, aux);
	        if(Comprobar_Valor(pos, aux) == TRUE)
	        {
	            result.Contenido[posicion++] = Valor;
	            result.Contenido[posicion++] = ' ';
	        }
	        Valor++;
	    }
	    aux.pVal = ' '; 
	    Poner_Valor(pos, aux);
	    result.Contenido[posicion++] = '\0';
	}
	
	return &result;
}

RCadena *
getsudoku_1_svc(int *argp, struct svc_req *rqstp) //FUNCIONA
{
	static RCadena  result; //Cadena pSudo
	
	Cadena Numero;
	Cadena Codigo;
	int pos = BuscarSudoku(*argp);
	
	sprintf(Codigo, "%d", *argp);
    	strcpy(result.Contenido, "Codigo del Juego: ");
    	strcat(result.Contenido, Codigo);
	
	strcat(result.Contenido, "\tDificultad: ");
    	if(pos == -1)
    	{
    	    strcat(result.Contenido,"Vacío");
    	}
    	else
    	{
    	    switch (Sudokus[pos].Dificultad)
    	    {
    	        case MUY_FACIL:
        		strcat(result.Contenido,"Muy Fácil");
            		break;
            	case FACIL:
        		strcat(result.Contenido,"Fácil");
            		break;
    	    	case MEDIA:
        		strcat(result.Contenido,"Media");
        		break;
    	    	case DIFICIL:
        		strcat(result.Contenido,"Difícil");
            		break;
    	    	case MUY_DIFICIL:
        		strcat(result.Contenido,"Muy Difícil");
        		break;
     	    	default:
        		strcat(result.Contenido,"** Sudoku vacío **");
    	    }
    	}
    	
    	sprintf(Numero, "%d", Num_Huecos(pos));
    	strcat(result.Contenido, "\tHuecos: ");
    	strcat(result.Contenido, Numero);
    	strcat(result.Contenido, "\n  123 456 789\n");
    	
    	for (int f = 0; f < 9; f++)
    	{
    	    if (f % 3 == 0)
    	    	strcat(result.Contenido, " +---+---+---+\n");
    	    
    	    sprintf(Numero, "%d", f+1);
            strcat(result.Contenido, Numero);
            for (int c = 0; c < 9; c++)
            {
            	if (c % 3 == 0)
            	    strcat(result.Contenido, "|");
            	
            	TFC aux;
            	aux.pCod = *argp;
            	aux.pFil = f;
            	aux.pCol = c;
            	
            	sprintf(Numero, "%c", Obtener_Valor(pos, aux));
            	strcat(result.Contenido,Numero);
            }
            strcat(result.Contenido, "|\n");
    	}
    	strcat(result.Contenido," +---+---+---+\n");

	return &result;
}






